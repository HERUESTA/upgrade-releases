# Rubyパッチバージョンのコードリーディング手順書

Rubyのパッチバージョン（例: 3.4.3 → 3.4.4）のリリース内容を読み解くための手順です。
段階的にバージョンを追う（3.4.3→3.4.4→3.4.5→...）ことで、変更の文脈が追いやすくなります。

---

## 前提

- 対象: パッチバージョンのアップデート（バグ修正・セキュリティ修正が中心）
- 目的: 勉強としてリリース内容を理解する
- 所要時間: 1バージョンあたり1〜3時間（深掘りの度合いによる）

## 使うサイト

| サイト | 用途 |
|-------|------|
| https://www.ruby-lang.org/ja/news/ | リリースノート |
| https://github.com/ruby/ruby/releases | GitHubリリースページ（チケット一覧） |
| https://github.com/ruby/ruby/compare/v3_4_3...v3_4_4 | タグ間の差分 |
| https://bugs.ruby-lang.org/ | Rubyの公式バグトラッカー |

---

## ステップ1: リリースノートを読む

### やること

https://www.ruby-lang.org/ja/news/ にアクセスし、該当バージョンのリリースノートを読む。

### 確認すること

- セキュリティ修正があるか（CVE番号がついているか）
- バグ修正の概要（何件あるか、どんなカテゴリか）
- 同梱ライブラリの更新があるか
- 予定通りのリリースか、前倒しか（前倒しの場合は重要な修正が含まれている）

### 把握すべき粒度

「今回はバグ修正が○件、セキュリティ修正は○件」程度の全体像がわかればOK。

---

## ステップ2: リリースノートのリンク先を読む

### やること

リリースノートまたはGitHubリリースページに記載されているチケット（Bug #XXXXX）やPR（#XXXXX）のリンクを順番に開いて読む。

### 各チケットの読み方

1. **メタ情報を確認する**（ページ上部）
   - Status: 解決済み（Closed）かどうか
   - Backport: どのバージョンに適用されたか
   - Assignee: 誰が担当したか

2. **Descriptionの冒頭を読む**
   - 最初の数行で「何のバグか」がわかることが多い
   - 再現コードがあれば目を通す

3. **最後のほうのコメントを見る**
   - 「Applied in changeset ...」→ 修正コミットのメッセージに要約がある
   - Backportのステータス変遷（REQUIRED → DONE）

4. **興味があれば中間のコメントを読む**
   - 開発者同士の議論（なぜこの修正方法を選んだか）

### PRの場合

- PRの説明文が薄いことがある（特にバックポート用PRは「This is a backport of #XXXX」だけのことも）
- その場合は元のPR番号を辿る
- それでも情報が薄ければ「ふーん」程度で次に進んでOK

### 把握すべき粒度

各チケットを1〜2行で要約できる程度。例:
- 「transform_values!のブロック内でrehashするとクラッシュするバグの修正」
- 「GCC 15でWindows環境のビルドが失敗する問題の修正」

### Tips

- 自分が知らない用語には📝で注釈をつけておくと後で見返しやすい
- 全てのチケットを同じ深さで読む必要はない
- 自分の環境に関係しない修正（例: Windowsを使わないならWindows系のバグ）は軽く流してOK

---

## ステップ3: タグ間のコミットログを読む

### やること

GitHubのcompareページまたは`git log`でコミットメッセージの一覧を確認する。

```bash
# ローカルにリポジトリがある場合
git log --oneline v3_4_3...v3_4_4

# なければGitHubで確認
# https://github.com/ruby/ruby/compare/v3_4_3...v3_4_4
```

### 確認すること

ステップ2で既に把握したチケットを除外し、**リリースノートに載っていないコミット**をピックアップする。

### コミットメッセージの分類（キーワードで機械的に判断）

**気になる（後で深掘り候補）:**

| キーワード | 意味 |
|-----------|------|
| `CVE-` | セキュリティ修正。実務でも重要 |
| `Bug #` | バグ修正。チケット番号があるのでステップ2と同じ方法で辿れる |
| `Revert` | 一度入れた修正が取り消されている。何か問題があった証拠 |
| `Fix` | 何かの修正 |

**ふーんで流してOK:**

| キーワード | 意味 |
|-----------|------|
| `Bump` + CI関連 | GitHub Actionsやイメージのバージョンアップ |
| `Use windows-XXXX` / `ubuntu-XX.XX` | CI環境の変更 |
| `Rename` | 名前変更 |
| `rubocop` | コードスタイルの修正 |
| `Skip ... test` | テストの一時的なスキップ |

### 把握すべき粒度

コミットメッセージだけで分類する。コードは見ない。
「リリースノートに載っていないセキュリティ修正やRevertを見つける」のがこのステップの価値。

### 気になるコミットを見つけたら

- チケット番号（Bug #XXXXX）があれば → ステップ2と同じ方法でチケットを辿る
- チケット番号がなければ → ステップ4でdiffを見る候補としてメモする

---

## ステップ4: テストコードのdiffを読む

### やること

ステップ2・3で気になったバグの修正コミットを開き、テストファイル（`test/`配下）の変更を先に読む。

```bash
# 特定コミットのテストコードだけを表示
git show <コミットハッシュ> -- test/
```

### 選ぶ基準

全てのコミットのテストを読む必要はない。以下の基準で選ぶ:

**優先して読むもの:**
- 自分が普段使う機能に関係する修正
- セキュリティ修正（CVE）
- 再現コードがRubyで書かれている修正

**後回し・スキップでいいもの:**
- 自分の環境に関係しない修正（例: Windowsを使わないならWindows系）
- Cレベルの深い修正（addr2line.cなど）
- CI/インフラ系（テストコードのdiffがないことが多い）

### 読み方

テストコードは「修正前はこう動いていた、修正後はこう動くべき」を示している。

```ruby
# 例: Bug #21331のテスト
x = (1..1337).to_h {|k| [k, k]}
assert_raise_with_message(RuntimeError, /rehash during iteration/) do
  x.transform_values! {|v|
    x.rehash if v == 1337
    v * 2
  }
end
```

このテストから読み取ること:
- `transform_values!`のブロック内で`rehash`を呼ぶ操作をしている
- 期待される動作: `RuntimeError`（"rehash during iteration"）が発生すること
- つまり修正前はクラッシュしていたが、修正後はエラーで安全に止まるようになった

### 把握すべき粒度

「このテストは何を検証しているか」「修正後の期待動作は何か」がわかればOK。

### Tips

- バグ単位で見る（コミット単位ではない）。1つのバグに複数コミットが紐づくことがある
- Revertされたコミットのテストは読まなくてよい。最終的に採用されたコミットのテストを読む
- diffで追加された行（`+`の行）に集中する。既存コードの精読は目的が違う

---

## ステップ5: 本体コードのdiffを読む

### やること

ステップ4でテストを読んだコミットの、本体コード（C言語やRubyのライブラリコード）のdiffを読む。

```bash
# テスト以外の変更を表示
git show <コミットハッシュ> -- hash.c  # 特定ファイルを指定
```

### 読み方

テストで「期待動作」を理解した上で本体を読む。

```c
// 例: Bug #21331の修正
static void
transform_values(VALUE hash)
{
    hash_iter_lev_inc(hash);    // イテレーションレベルを+1
    rb_ensure(transform_values_call, hash,
              hash_foreach_ensure, hash);  // 終了時に必ずレベルを-1
}
```

テストから「イテレーション中のrehashを禁止すべき」とわかっているので、
「hash_iter_lev_incでイテレーション中フラグを立てて、rehashを検知できるようにした」と理解できる。

### 把握すべき粒度

- 変更が小さい（2〜3行）+ コミットメッセージが明確 → 「何をしたか」がわかればOK
- 変更が大きい → 全部理解しようとせず、追加された関数の名前や構造で「方針」を掴む
- C言語が難しければ、関数名やコメントから意図を推測するだけでも価値がある

### Tips

- コメントの追加・変更にも注目する。「This does not manage iteration level」のような注釈は設計意図を示している
- 全てのdiffを理解する必要はない。興味のある部分だけ深掘りすればよい

---

## ステップ6: 再現してみる（余裕があれば）

### やること

面白いバグ修正を見つけたら、修正前のバージョンでバグを再現し、修正後のバージョンで直っていることを確認する。

```bash
# 修正前のバージョンをインストール
rbenv install 3.4.3
rbenv shell 3.4.3

# 再現コードを実行
ruby -e '
$a = (1..1337).to_h { |k| [k, k] }
$a.transform_values! { |v|
    $a.rehash
    v * 2
}
'
# → クラッシュするはず

# 修正後のバージョンに切り替え
rbenv install 3.4.4
rbenv shell 3.4.4

# 同じコードを実行
# → RuntimeError: rehash during iteration が出るはず
```

### このステップのメリット

- 手を動かすと記憶に残りやすい
- バグの影響範囲を実感できる
- テストの書き方の参考になる

---

## まとめ: 全体の流れ

```
ステップ1: リリースノート    → 全体像の把握（何件、どんな種類）
ステップ2: チケット/PRを辿る → 各修正の背景と議論を把握
ステップ3: コミットログ      → リリースノートに載っていない変更を発見
ステップ4: テストコードのdiff → 修正後の期待動作を理解
ステップ5: 本体コードのdiff  → 具体的な修正内容を理解
ステップ6: 再現（任意）      → 手を動かして確認
```

上から下に向かって粒度が細かくなる。途中で興味がなければそこで次の修正に移ればOK。
全てのチケットをステップ6まで追う必要はなく、1〜2件を丁寧に追うほうが学びになる。